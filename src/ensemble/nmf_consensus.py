# TODO: proper references in the proper spot

# From: https://github.com/tsano430/ClusterEnsembles/blob/main/ClusterEnsembles/ClusterEnsembles.py
#  Taken due to broken Kahypar


# ClusterEnsembles.py
#   Author: Takehiro Sano
#   Contact: tsano430@gmail.com
#   License: MIT License


import numpy as np
from scipy import sparse
from sklearn.utils.extmath import safe_sparse_dot


def create_connectivity_matrix(labels):
    n_labels, len_labels = labels.shape
    M = np.zeros((len_labels, len_labels))
    m = np.zeros_like(M)

    for label in labels:
        for i, elem in enumerate(label):
            m[i] = np.where(elem == label, 1, 0)
        M += m

    M /= n_labels
    return sparse.csr_matrix(M)


def orthogonal_nmf_algorithm(W, nclass, maxiter=200):
    """Algorithm for bi-orthogonal three-factor NMF problem.
    Parameters
    ----------
    W: Given matrix.
    maxiter: Maximum number of iterations.
    Return
    -------
    Q, S: Factor matrices.
    """

    n = W.shape[0]
    Q = np.random.rand(n, nclass).reshape(n, nclass)
    S = np.diag(np.random.rand(nclass))

    for _ in range(maxiter):
        # Update Q
        WQS = safe_sparse_dot(W, np.dot(Q, S), dense_output=True)
        Q = Q * np.sqrt(WQS / (np.dot(Q, np.dot(Q.T, WQS)) + 1e-8))
        # Update S
        QTQ = np.dot(Q.T, Q)
        WQ = safe_sparse_dot(W, Q, dense_output=False)
        QTWQ = safe_sparse_dot(Q.T, WQ, dense_output=True)
        S = S * np.sqrt(QTWQ / (np.dot(QTQ, np.dot(S, QTQ)) + 1e-8))

    return Q, S


def nmf_consensus(labels: np.ndarray):
    """Generate a single consensus clustering label by using base labels
       obtained from multiple clustering algorithms.
    Parameters
    ----------
    labels: Labels generated by multiple clustering algorithms such as K-Means.

    Return
    -------
    label_ce: Consensus clustering label.
    """

    if not (type(labels) == np.ndarray):
        labels = np.array(labels)

    nclass = -1
    for label in labels:
        len_unique_label = len(np.unique(label[~np.isnan(label)]))
        nclass = max(nclass, len_unique_label)
    if not (nclass > 0):
        raise ValueError(f'Number of class must be a positive integer; got (nclass={nclass})')

    # NMF
    M = create_connectivity_matrix(labels)
    Q, S = orthogonal_nmf_algorithm(M, nclass)  # TODO: deal with max iter?
    label_ce = np.argmax(np.dot(Q, np.sqrt(S)), axis=1)

    return label_ce
