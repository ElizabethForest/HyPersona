# From: https://github.com/tsano430/ClusterEnsembles/blob/main/ClusterEnsembles/ClusterEnsembles.py
# ClusterEnsembles.py
#   Author: Takehiro Sano
#   Contact: tsano430@gmail.com
#   License: MIT License

import numpy as np
from scipy import sparse
from sklearn.utils.extmath import safe_sparse_dot


def create_connectivity_matrix(labels):
    n_labels, len_labels = labels.shape
    M = np.zeros((len_labels, len_labels))
    m = np.zeros_like(M)

    for label in labels:
        for i, elem in enumerate(label):
            m[i] = np.where(elem == label, 1, 0)
        M += m

    M /= n_labels
    return sparse.csr_matrix(M)


def orthogonal_nmf_algorithm(W, nclass):
    """Algorithm for bi-orthogonal three-factor NMF problem.
    Parameters
    ----------
    W: Given matrix.
    maxiter: Maximum number of iterations.
    Return
    -------
    Q, S: Factor matrices.
    """

    n = W.shape[0]
    Q = np.random.rand(n, nclass).reshape(n, nclass)
    S = np.diag(np.random.rand(nclass))

    for _ in range(200):
        # Update Q
        WQS = safe_sparse_dot(W, np.dot(Q, S), dense_output=True)
        Q = Q * np.sqrt(WQS / (np.dot(Q, np.dot(Q.T, WQS)) + 1e-8))
        # Update S
        QTQ = np.dot(Q.T, Q)
        WQ = safe_sparse_dot(W, Q, dense_output=False)
        QTWQ = safe_sparse_dot(Q.T, WQ, dense_output=True)
        S = S * np.sqrt(QTWQ / (np.dot(QTQ, np.dot(S, QTQ)) + 1e-8))

    return Q, S


def nmf_consensus(labels: np.ndarray):
    """Generate a single consensus clustering label using base labels
       obtained from multiple clustering algorithms with NMF.
    Parameters
    ----------
    labels: Labels generated by multiple clustering algorithms such as K-Means.

    Return
    -------
    label_ce: Consensus clustering label.

    References:
    -----------
    The implementation of nmf_consensus is from the ClusterEnsembles by Takehiro Sano (tsano430)
    see https://github.com/tsano430/ClusterEnsembles
    """


    nclass = -1
    for label in labels:
        if -1 in label:
            raise ValueError("Negative cluster label (often used for noise)- cluster labels must be >= 0")
        if len(label) != len(labels[0]):
            raise ValueError("Each set of labels in the label_matrix must be the same length")

        # len_unique_label = len(np.unique(label[~np.isnan(label)]))
        nclass = max(nclass, max(label) + 1)
        # k = max(k, max(labels) + 1)

    if not (type(labels) == np.ndarray):
        labels = np.array(labels, np.int32)

    M = create_connectivity_matrix(labels)
    Q, S = orthogonal_nmf_algorithm(M, nclass)
    label_ce = np.argmax(np.dot(Q, np.sqrt(S)), axis=1)

    return label_ce
